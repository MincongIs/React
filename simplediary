리액트에서 사용자입력 처리하기

1. npx create-react-app simplediary 
2. 폴더생성후 정리 -> 사용하지 않는 파일 삭제 app.test.js, logo.svg, reportWebWitals.js , setupTest.js 등..
3. 사용자의 입력을 처리하기 위해서 state사용 
4. input 에 스테이트 초기값 author 를 값으로 넣어준다. 이 값이 변경이 되야지 상태가 반영이 된다 onChange={콜백함수} 이벤트(사용자의행동감지) 사용하기 
이 콜백함수는 이벤트 객체 e를 전달 받는다 
이벤트 객체의 e.tatget.value값이 사용자가 입력한 값이다.
5. textarea추가하기 
input과 textarea의 state가 비슷하기 때문에 두개를 하나로 묶어줗수 있다 
----
const DiaryEditor = () => {
const [state, setState] = useState({
  author: "",
  contents: "",
});

<input
  value={state.author}
  onChange={(e) => {
    setState({
      author: e.target.value,
      contents: state.contents,
    });
  }}
/>
<textarea
  value={state.contents}
  onChange={(e) => {
    setState({
      contents: e.target.value,
      author: state.author,
    });
  }}
/>
----
-묶여 있는 값이 여러개인경우 ...state 스프래드 연산자를 이용한다 
---->>
<input
    value={state.author}
    onChange={(e) => {
      setState({
          ...state,
        author: e.target.value,
      });
    }}
  />
----
6. 두개의 이벤트 핸들러 합치기
const handleChangeState = (e) => {
    setState({
      ...state,
      [e.target.name]: e.target.value, // 타겟의 이름에따라 value값이 바뀐다
    });
  };
7. 감정선택만들기
----
<select
    name="emotion"
    value={state.emotion}
    onChange={handleChangeState}
  >
    <option value={1}>1</option>
    <option value={2}>2</option>
    <option value={3}>3</option>
    <option value={4}>4</option>
    <option value={5}>5</option>
  </select>
-----
diaryEditor 함수에 emotion: "1", 추가 

8. 저장버튼만들기
----
const handleSubmit = () => {
    console.log(state);
    alert("저장 성공");
  };
----
<div>
        <button onClick={handleSubmit}>일기 저장하기</button>
      </div>
----

리액트에서 dom조작하기
useRef
입력이 제대로 들어왔는지 확인하기 
1. handleSubmint 저장버튼에 기능추가하기 
 
const handleSubmit = () => {
  if (state.author.length < 1) {
    alert("작성자는 최소 1글자 이상 입력해주세요");
    return;
  }

  if (state.contents.length < 5) {
    alert("일기본문은 최소 5글자 이상 입력해주세요");
    return;
  }
  alert("저장 성공");
};

---> alert보다 포커스를 줘서 수정하게 하자 
1. 포커스를 해야하는 요소는 2개이다 input 과 textarea ==> 두개의 엘리먼트에 useRef를 이용해서 접근해야함
const authorInput = useRef(); //useRef를 호출해서 authorinput 에 담으면 안데 react.mutableRefernce 가 담긴다 (돔요소를 접근할수 있는 기능)
2. <input ref={authorInput}> .... input에 authorInput 전달하기   
3. authorInput.current.focus(); // alert()메세지 지우고 handleSubmit에 추가해주기 
4. textarea에도 똑같이 해준다 끝

리스트 사용하기
1. 작성된 일기들은 배열에 저장이 된다 배열에 아이템을 저장해 리스트 형태로 랜더링이 됨 --> 일기리스트에 일기들이 배열이 되게 만들기 
2. 연습을 위해 app.js 에 더미를 만들어 준다 
app.js
const dummyList =[
{
  id:1,
  author:"진민영",
  content:"하이 1",
  emotion:5,
  created_date: new Date().getTime() // date객체에 아무값도 넣지 않으면 현재시간이 나온다 getTime()매서드를 사용해 milliseconds로 불러온다
}

--> 이 더미 리스트를 <DiaryList /> 모듈에 객체로 값을 넘겨준다
3. DiaryList.js
----
<div>
  {dirayList.map((it) => (
    <div>일기 아이템</div>
  ))}
</div>
---->>> map의 리터값이 div로 들어오게 됨 
이것을 실제 데이터에 적용하기 
----->
<div>
  {dirayList.map((it) => (
    <div>
      <div>작성자 : {it.author}</div>
      <div>일기 : {it.content}</div>
      <div>감정 : {it.emotion}</div>
      <div>작성 시간 : {it.created_date}</div>
    </div>
  ))}
</div>
----

4. undefied 값이 나오는것을 대비해서 
DiaryList.defaultProps={
    diaryList:[]
}
를 하단에 추가한다 

5. key props만들기
<div key={it.id}>  -->리스트를 감싸는 div에 추가 

6. 리스트 컴포넌트 따로 만들기 
DiaryItem.js 를 따로 만든다 
---DiaryList.js 
<div>
  {dirayList.map((it) => (
    <DiaryItem key={it.id} {...it} />
  ))}
</div>
---

리스트 추가하기 
1. 컴포넌트의 데이터 & 구조
리액트는 단방향으로 데이터, 역방향 이벤트가 흐른다
공통부모요소로 state를 가지고 있으면 두 자식요소에 값을 보낼수 있다 

app.js [data, setData]      <<<-------ㄱ
    ->> setData --> DiaryEditor --> 새로운일기작성
 ㄴ->> 추가된 data  --> DiaryList 
새로운 일기가 작성이되면 setData함수가 호출이 되고 data의 상태가 바뀐다 data에 새로운 일기가 추가가 되고 DiaryList에 새로운 데이터가 프랍으로 전달된다 
  ↓         ↑
데이터    이벤트
  ↓         ↑
(데이터는 위에서 아래로 , 이벤트는 아래에서 위로 )

2. 
----app.js
const [data, setData] = useState([]);

const dataId = useRef(0); //id를 useRef를 이용해서 만들어 줌

const onCreate = (author, content, emotion) => { // setData를 이용해서 사용자가 작성한 값을 받아 다시 data에 업데이트 시키는 로직을 작성함
  const created_date = new Date().getTime();
  const newItem = { //새로운 일기 아이템으로 추가되어야 하는것 
    author,
    content,
    emotion,
    created_date,
    id: dataId.current
  };
 dataId.current += 1;// 다음 아이디에 +1증가 시킴 
 setData([newItem, ...data]); // 기존 data 위에 newItem 을 추가한다
};

<DiaryEditor onCreate={onCreate}/>// 일기를 추가하는 함수인 onCreate를 diaryEditor에 prop으로 추가함
<DirayList dirayList={data} /> // 일기 배열인 data값을 diaryList에 내려준다
----

----DiaryEditor.js
const DiaryEditor = ({ onCreate }) => {.......   //prop으로 값을 받는다 
.
.
.
onCreate(state.author, state.contents, state.emotion);// 작성한 값을 가져온다
alert("저장 성공");
setState({    ///일기 작성 저장후에 값을 초기화 해준다
  author: "",
  contents: "",
  emotion: 1,
});
---
정리 
1.app컴로넌트가 diaryEditor와 diaryList가 사용할 data값을 가지고 있다 
초기값은 빈배열임
2.diaryLIst에는 현재 상태인 data값을 넘겨주기만 하면된다 -> app컴포넌트의 data값이 변하면 diaryList도 다시 랜더링 된다 
3. 사용자각 작성을 하면 data의 상태가 변한다 
4. app컴포넌트에 onCreate라는 함수를 만든다 이 함수는 작성자와 컨텐트 이모션을 전달 받는다  
5. handleSubmit 즉 일기 저장이 일어났을때 onCreate함수를 호출해서 현재 컴포넌트의 값을 app으로 전달한다
6 그러면 onCreate에서 값을 받아 newItem을 만들어서 setData함수를 호출해서 리스트의 가장위로 newItem 이 추가된다 

리스트 데이터 삭제하기 
1. 각각의 아이템에 삭제버튼 만들기
2. app 컴포넌트의  data의 state를 바꿔줘야함
3. app컴포넌트에 삭제함수, onDelete() 추가 
3. diaryList 에서 onDelete함수를 호출할수 있어야한다 props으로 onDelete함수를 받고 다시 diaryItem에 전달해준다
4. diaryItem에서 
----
<button
  onClick={() => {
    console.log(id);
    if(window.confirm(`${id}번째 일기를 삭제하시겠습니까?`)){//window.confirm()사용해서 삭제하기전 창띄우기
      onDelete(id); //확인을 누르면 onDelete에 id전달 
    }
  }}
>
  삭제하기
</button>
----
const onDelete = (targetId) => {
  console.log(`${targetId}가 삭제되었습니다`);
  const newDiaryList = data.filter((it) => it.ld !== targetId);// n번 요소를 재외한 나머지 요소로 fiter()함수를 이용해서 배열을 만든다 
  console.log(newDiaryList);
};

정리
삭제함수가 수행 (이되면서 전달받은 타겟아이디만 포함하지 않은 배열로 새롭게 만들어서) data
상태를 변화시키면 diaryList모듈이 다시 랜더링 되면서 diaryList={data}에서 새로운 배열값을 출력한다 
