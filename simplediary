리액트에서 사용자입력 처리하기

1. npx create-react-app simplediary 
2. 폴더생성후 정리 -> 사용하지 않는 파일 삭제 app.test.js, logo.svg, reportWebWitals.js , setupTest.js 등..
3. 사용자의 입력을 처리하기 위해서 state사용 
4. input 에 스테이트 초기값 author 를 값으로 넣어준다. 이 값이 변경이 되야지 상태가 반영이 된다 onChange={콜백함수} 이벤트(사용자의행동감지) 사용하기 
이 콜백함수는 이벤트 객체 e를 전달 받는다 
이벤트 객체의 e.tatget.value값이 사용자가 입력한 값이다.
5. textarea추가하기 
input과 textarea의 state가 비슷하기 때문에 두개를 하나로 묶어줗수 있다 
----
const DiaryEditor = () => {
const [state, setState] = useState({
  author: "",
  contents: "",
});

<input
  value={state.author}
  onChange={(e) => {
    setState({
      author: e.target.value,
      contents: state.contents,
    });
  }}
/>
<textarea
  value={state.contents}
  onChange={(e) => {
    setState({
      contents: e.target.value,
      author: state.author,
    });
  }}
/>
----
-묶여 있는 값이 여러개인경우 ...state 스프래드 연산자를 이용한다 
---->>
<input
    value={state.author}
    onChange={(e) => {
      setState({
          ...state,
        author: e.target.value,
      });
    }}
  />
----
6. 두개의 이벤트 핸들러 합치기
const handleChangeState = (e) => {
    setState({
      ...state,
      [e.target.name]: e.target.value, // 타겟의 이름에따라 value값이 바뀐다
    });
  };
7. 감정선택만들기
----
<select
    name="emotion"
    value={state.emotion}
    onChange={handleChangeState}
  >
    <option value={1}>1</option>
    <option value={2}>2</option>
    <option value={3}>3</option>
    <option value={4}>4</option>
    <option value={5}>5</option>
  </select>
-----
diaryEditor 함수에 emotion: "1", 추가 

8. 저장버튼만들기
----
const handleSubmit = () => {
    console.log(state);
    alert("저장 성공");
  };
----
<div>
        <button onClick={handleSubmit}>일기 저장하기</button>
      </div>
----

리액트에서 dom조작하기
useRef
입력이 제대로 들어왔는지 확인하기 
1. handleSubmint 저장버튼에 기능추가하기 
 
const handleSubmit = () => {
  if (state.author.length < 1) {
    alert("작성자는 최소 1글자 이상 입력해주세요");
    return;
  }

  if (state.contents.length < 5) {
    alert("일기본문은 최소 5글자 이상 입력해주세요");
    return;
  }
  alert("저장 성공");
};

---> alert보다 포커스를 줘서 수정하게 하자 
1. 포커스를 해야하는 요소는 2개이다 input 과 textarea ==> 두개의 엘리먼트에 useRef를 이용해서 접근해야함
const authorInput = useRef(); //useRef를 호출해서 authorinput 에 담으면 안데 react.mutableRefernce 가 담긴다 (돔요소를 접근할수 있는 기능)
2. <input ref={authorInput}> .... input에 authorInput 전달하기   
3. authorInput.current.focus(); // alert()메세지 지우고 handleSubmit에 추가해주기 
4. textarea에도 똑같이 해준다 끝

리스트 사용하기
1. 작성된 일기들은 배열에 저장이 된다 배열에 아이템을 저장해 리스트 형태로 랜더링이 됨 --> 일기리스트에 일기들이 배열이 되게 만들기 
2. 연습을 위해 app.js 에 더미를 만들어 준다 
app.js
const dummyList =[
{
  id:1,
  author:"진민영",
  content:"하이 1",
  emotion:5,
  created_date: new Date().getTime() // date객체에 아무값도 넣지 않으면 현재시간이 나온다 getTime()매서드를 사용해 milliseconds로 불러온다
}

--> 이 더미 리스트를 <DiaryList /> 모듈에 객체로 값을 넘겨준다
3. DiaryList.js
----
<div>
  {dirayList.map((it) => (
    <div>일기 아이템</div>
  ))}
</div>
---->>> map의 리터값이 div로 들어오게 됨 
이것을 실제 데이터에 적용하기 
----->
<div>
  {dirayList.map((it) => (
    <div>
      <div>작성자 : {it.author}</div>
      <div>일기 : {it.content}</div>
      <div>감정 : {it.emotion}</div>
      <div>작성 시간 : {it.created_date}</div>
    </div>
  ))}
</div>
----

4. undefied 값이 나오는것을 대비해서 
DiaryList.defaultProps={
    diaryList:[]
}
를 하단에 추가한다 

5. key props만들기
<div key={it.id}>  -->리스트를 감싸는 div에 추가 

6. 리스트 컴포넌트 따로 만들기 
DiaryItem.js 를 따로 만든다 
---DiaryList.js 
<div>
  {dirayList.map((it) => (
    <DiaryItem key={it.id} {...it} />
  ))}
</div>
---

리스트 추가하기 
1. 컴포넌트의 데이터 & 구조
리액트는 단방향으로 데이터, 역방향 이벤트가 흐른다
공통부모요소로 state를 가지고 있으면 두 자식요소에 값을 보낼수 있다 

app.js [data, setData]      <<<-------ㄱ
    ->> setData --> DiaryEditor --> 새로운일기작성
 ㄴ->> 추가된 data  --> DiaryList 
새로운 일기가 작성이되면 setData함수가 호출이 되고 data의 상태가 바뀐다 data에 새로운 일기가 추가가 되고 DiaryList에 새로운 데이터가 프랍으로 전달된다 
  ↓         ↑
데이터    이벤트
  ↓         ↑
(데이터는 위에서 아래로 , 이벤트는 아래에서 위로 )

2. 
----app.js
const [data, setData] = useState([]);

const dataId = useRef(0); //id를 useRef를 이용해서 만들어 줌

const onCreate = (author, content, emotion) => { // setData를 이용해서 사용자가 작성한 값을 받아 다시 data에 업데이트 시키는 로직을 작성함
  const created_date = new Date().getTime();
  const newItem = { //새로운 일기 아이템으로 추가되어야 하는것 
    author,
    content,
    emotion,
    created_date,
    id: dataId.current
  };
 dataId.current += 1;// 다음 아이디에 +1증가 시킴 
 setData([newItem, ...data]); // 기존 data 위에 newItem 을 추가한다
};

<DiaryEditor onCreate={onCreate}/>// 일기를 추가하는 함수인 onCreate를 diaryEditor에 prop으로 추가함
<DirayList dirayList={data} /> // 일기 배열인 data값을 diaryList에 내려준다
----

----DiaryEditor.js
const DiaryEditor = ({ onCreate }) => {.......   //prop으로 값을 받는다 
.
.
.
onCreate(state.author, state.contents, state.emotion);// 작성한 값을 가져온다
alert("저장 성공");
setState({    ///일기 작성 저장후에 값을 초기화 해준다
  author: "",
  contents: "",
  emotion: 1,
});
---
정리 
1.app컴로넌트가 diaryEditor와 diaryList가 사용할 data값을 가지고 있다 
초기값은 빈배열임
2.diaryLIst에는 현재 상태인 data값을 넘겨주기만 하면된다 -> app컴포넌트의 data값이 변하면 diaryList도 다시 랜더링 된다 
3. 사용자각 작성을 하면 data의 상태가 변한다 
4. app컴포넌트에 onCreate라는 함수를 만든다 이 함수는 작성자와 컨텐트 이모션을 전달 받는다  
5. handleSubmit 즉 일기 저장이 일어났을때 onCreate함수를 호출해서 현재 컴포넌트의 값을 app으로 전달한다
6 그러면 onCreate에서 값을 받아 newItem을 만들어서 setData함수를 호출해서 리스트의 가장위로 newItem 이 추가된다 

리스트 데이터 삭제하기 
1. 각각의 아이템에 삭제버튼 만들기
2. app 컴포넌트의  data의 state를 바꿔줘야함
3. app컴포넌트에 삭제함수, onDelete() 추가 
3. diaryList 에서 onDelete함수를 호출할수 있어야한다 props으로 onDelete함수를 받고 다시 diaryItem에 전달해준다
4. diaryItem에서 
----
<button
  onClick={() => {
    console.log(id);
    if(window.confirm(`${id}번째 일기를 삭제하시겠습니까?`)){//window.confirm()사용해서 삭제하기전 창띄우기
      onDelete(id); //확인을 누르면 onDelete에 id전달 
    }
  }}
>
  삭제하기
</button>
----
const onDelete = (targetId) => {
  console.log(`${targetId}가 삭제되었습니다`);
  const newDiaryList = data.filter((it) => it.ld !== targetId);// n번 요소를 재외한 나머지 요소로 fiter()함수를 이용해서 배열을 만든다 
  console.log(newDiaryList);
};
----
정리
삭제함수가 수행 (이되면서 전달받은 타겟아이디만 포함하지 않은 배열로 새롭게 만들어서) data
상태를 변화시키면 diaryList모듈이 다시 랜더링 되면서 diaryList={data}에서 새로운 배열값을 출력한다 



리스트 데이터 수정하기
1. 삭제하기 버튼 옆에 수정하기 버튼 추가
2. 버튼클릭시 수정하는 폼이 만들어져야한다 useState로 상태추가
const [isEdit, setEdit] = useState(false); 
--> 값이 true면 수정중인 상태isEdit, 수정중이 아니면 setEdit
--> isEdit 값이 true가 되면 jsx에서 수정가능 
3. setEdit의 값을 반대로 만드는 toggleISEdit 만들기 -> 수정하기버튼을 클릭하면 작동함
const toggleIsEdit = ()=> setEdit(!isEdit);
4. 일기장 본문을 블리언 값에 따라 수정하기와 콘텐츠 보여주기로 나눠준다
5. 수정할때 사용한 textarea의 input을 핸들링할 state를 추가한다 
--> const [localContent, setLocalContent] = useState("");
6.textarea의 입력한 value를 localContent에서 사용하도록 셋팅해준다
<textarea value={localContent} onChange={(e) => setLocalContent(e.target.value)}/>
7. 수정중인 상태에 따라 버튼도 다르게 보여주자 
-->{isEdit?<></> : <></>} 여기안에 버튼 넣어주기
8. 수정폼의 기본값을 기존의 content로 바꿔준다
-->  const [localContent, setLocalContent] = useState(content);
9. 수정중 취소하면 다시 수정전 컨첸트 보여주기
-->
const handleQuitEdit = ()=>{
  setIsEdit(false);
  setLocalContent(content);   // 원래 컨텐츠를 넣어준다
}
10. app컴포넌트에서 수정하는 함수를 만들어서 diaryItem까지 보내줘야한다 
-->
const onEdit = (targetId, newContent)=>{
  setData(
    data.map((it)=> it.id === targetId ? {...it, content:newContent}:it) // 수정대상이면 컨텐츠를 교체하고 아니면 원래값을 리턴한다
  )
}
11. 수정완료 버튼을 만들었을때 처리할 함수 만들기 
----
const handleEdit = ()=>{
  if(localContent.length<5){ // 5자 이하 입력시
    return; //아무일도 일어나지않는다
  }

  onEdit(id,localContent) // 고유 아이디와 수정한 컨텐츠내용 보내기
}
----
12. ref이용해서 5글자 미만인 경우 포커스 넣어주기
--> const localContentInput = useRef();
--> localContentInput.current.focus();
13.


컴포넌트 생애 주기 제어하기 
react component lifecyle mathod
------------------------------->
mount update unmount

React hooks (19.06출시)
useState, useRef, useEffect 등....
use를 사용하여 함수처럼 사용한다 

클래스형이 아니고 함수형 컴포넌트를 사용하는 이유는 뭘까?
-> 중복 코드와 가독성 해결을 위해

사용법
useEffect(()=>{},[]) --> 콜백함수와 배열, 두개의 인자를 받는다
배열의 값이 변화하면 콜백함수가 실행한다 

라이프사이클 제어하기 
1. Lifecycle.js 파일 생성 
2.app에 Lifecycle컴포넌트를 추가해준다
----
<div style={{ padding: 20 }}>
    <div>
      {count}
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
    <div>
      <input vlaue={text} onChange={(e) => setText(e.target.value)} />
    </div>
  </div>
----
3. mount되는 시점 제어하기 -> useEffect 사용 
useEffect(() => {
  console.log("mount!");// --> 빈 배열을 전달하고 mount 될때 할일은 콜백함수에 넣는다 
}, []);
--> 빈 배열을 전달 한다 . mount 되는 시점에만 작동해서 업데이트를 해도 호출되지 않는다
4. 컴포넌트가 업데이트 되는 순간 제어하기 
useEffect(() => {
  console.log("Udate!");// 컴포넌트가 업데이트 될때 할일 
});
--> 배열을 전달 하지 않고 확인하기 
--> 컴포넌트가 업데이트 되는 순간에 useEffect 가 계속 호출된다
5. useEffect의 특별한 기능
버튼을 클릭하거나 text변경시 콜백함수 수행하기 테스트 
----
useEffect(() => {
  console.log(`count is upadte : ${count}`);
}, [count]);

useEffect(() => {
  console.log(`text is update:${text}`);
}, [text]);
----
---> 우리가 감지하고 싶은것만 감지해서  그 값이 업데이트 되었을때 콜백함수를 실행하게 할수 있다

컴포넌트가 unmount 되는 순간 제어하기 데스트
1.{isVisible && <UnmountTest/>} //단락회로평가이용
----
/자식 컴포넌트 생성
const UnmountTest = () => {
  useEffect(() => {
    console.log("Mount!");
    return () => {
      //unmount시점에 실행되게 됨
      console.log("Unmount");
    };
  }, []);
  return <div>unmount Testing Component</div>;
};

const Lifecycle = () => {
  const [isVisible, setVisible] = useState(false);
  const toggle = () => setVisible(!isVisible);

  return (
    <div style={{ padding: 20 }}>
      <button onClick={toggle}>ON/OFF</button>
      {isVisible && <UnmountTest />}
    </div>
  );
};
----


리액트에서 api호출하기
- useEffect를 이용해 컴포넌트 mount시점에 api를 호출하고 해당 api의 결과값을 일기데이터의 초기값으로 이용하기
1. jsonplaceholder이용 -> Resources -> comments 사용 
2. app.js 함수생성 
const getData = async()=>{ // promise를 반환하는 비동기함수로 만든다
    
}
-->
const getData = async () => {
  const res = await fetch(
    "https://jsonplaceholder.typicode.com/comments"
  ).then((res) => res.json());//json함수를 이용해서 json값들만 가져온다
  console.log(res);
};
3. mount되는 시점에 api호출 함수를 실행하게함
useEffect(()=>{
  getData();
},[]) //빈배열을 넣어주면 mount되는 시점에 콜백함수가 실행됨
4. res 상수에 저장된 값을 통해서 일기 데이테의 기초값을 설정하기 
----
const intiData= res.slice(0,20).map((it)=>{
    return {
      author:it.email,
      content: it.body,
      emotion:Math.floor(Math.random()*5)+1,
      created_date: new Date().getTime(),
      id:dataId.current++
    }
  })
---->
(Math.random()*5) -> 0~4까지의 수(소수점포함)를 반환한다
Math.floor() -> 정수로 바꿔주는 함수 


