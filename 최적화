useMemo 
memoization

1. appjs 리턴문 위에 3가지 함수를 만든다
const getDiaryAnalysis = ()=> {
  console.log("일기 분석 시작");
}
2. 기분좋은 일기 구하기 감정점수가 3이상인것 
  const goodCount = data.filter((it)=>it.emotion >=3).length;
3. 기분나쁜일기구하기
  const badCount = data.length-goodCount;
4. 좋은 일기 비율구하기
const goodRatio = (goodCount/ data.length)*100;
5. 3가지를 객체로 리턴하기
return {goodCount, badCount,goodRatio};

----
const getDiaryAnalysis = ()=> {
  console.log("일기 분석 시작");
  const goodCount = data.filter((it)=>it.emotion >=3).length;
  const badCount = data.length-goodCount;
  const goodRatio = (goodCount/ data.length)*100;
  return {goodCount, badCount,goodRatio};
}
----
6. 지역함수로 만든 getDiaryAnalysis()를 리턴전에 호출한다 
const {goodCount, badCount,goodRatio} = getDiaryAnalysis();
7. 이렇게 얻은 3개의 데이터를 호출한다 
<div>전체 일기 : {data.length}</div>
<div>기분 좋은 일기 개수 : {goodCount}</div>
<div>기분 나쁜 일기 개수 : {badCount}</div>
<div>기분 좋은 일기 비율 : {goodRatio}</div>

8. 리턴을 가지고 있는 함수를 memoization해서 연산을 최적화 하기 위해서는 useMemo()를 사용 
사용하고자하는 함수를 useMemo()함수로 감싸준다
 const getDiaryAnalysis = useMemo(() => {
  console.log("일기 분석 시작");
  const goodCount = data.filter((it) => it.emotion >= 3).length;
  const badCount = data.length - goodCount;
  const goodRatio = (goodCount / data.length) * 100;
  return { goodCount, badCount, goodRatio };
},[data.length]);
--> 즉 useMemo함수는 첫번째 인자로 콜백함수를 갖는다 
두번째로 전데이터의 갯수가 달라지면 콜백함수가 호출이 된다 
9. getDiaryAnalysis는 이제 함수가 아니고 콜백함수가 내보는값을 가지게 된다 

정리....
useMemo()는 첫번째 인자로 콜백함수를 가져서 콤백함수가 러턴하는 값의 연산을 최적화 할 수 있도록 해준다
두번째 인자로는 배열이 들어가는데 이 배열이 변화 할때만 콜백함수가 실행이 된다 
그렇다는것은 이 것을 아무리 호출을 해도 배열에 변화가 생기지않는 한 똑같이 이전에 계산했던 값만 리턴해서 내보낸다는 뜻이다.
즉 똑같은 문제를 풀어하는데 새로계산할 필요가 없으면 기존의 알고있던 답을 내놓는것과 같다
*** useMemo로 함수를 감싸서 최적화를 하면 더이상 함수가 아니라 값만 리턴하는 상태가 된다 




React.memo
컴포넌트 재사용 

부모가 리랜더 되면 자식 모두 리랜더 되기때문에 연산의 낭비가 발생하게 된다 
이 낭비를 막기위해서 각각 자식컴포넌트에서 각각의 prop이 바뀔때만 리런더 되게 조건을 걸어준다.
이것을 사용할수 있는 리액트의 기능이 React.memo 이다 

1. react docs 구글 검색
2. 똑같은 prop을 받으면 똑같은 값을 내놓는것 
3. React.memo로 리랜딩 되지 많아야할 함수를 감싸주면 부모컴포넌트에 대한 리랜더를 조절한다

주의***
객채를 비교하는 방법
js는 객체의 값이 아니고 객체의 주소를 비교하기때문에 같은 값을 가지고 있다고 같다고 판다하지 않는다

따라서 얕은 비교를 하지 않는 방법을 사용해야 한다 

----
import React, { useState, useEffect } from "react";

const CounterA = React.memo(({ count }) => {
  useEffect(() => {
    console.log(`CounterA update - conunt:${count}`);
  });
  return <div>{count}</div>;
});

const CounterB = React.memo(({ obj }) => {
  useEffect(() => {
    console.log(`CounterB update - count : ${obj.count}`);
  });
  return <div>{obj.count}</div>;
});

const areEqual = (prevprops, nextProps) => {
  if (prevprops.obj.count === nextProps.obj.count) {
    return true;
  }
  return false;
};
const MomoizationCounterB = React.memo(CounterB, areEqual);

const OptimizeTest = () => {
  const [count, setCount] = useState(1);
  const [obj, setObj] = useState({ count: 1 });
  return (
    <div style={{ padding: 50 }}>
      <div>
        <h2>Counter A</h2>
        <CounterA count={count} />
        <button onClick={() => setCount(count)}>A button</button>
      </div>
      <div>
        <h2>Counter B</h2>
        <MomoizationCounterB obj={obj} />
        <button onClick={() => setObj({ count: obj.count })}>B button</button>
      </div>
    </div>
  );
};

export default OptimizeTest;
----

----수정
const areEqual = (prevprops, nextProps) => {
  if (prevprops.obj.count === nextProps.obj.count) {
    return true;
  }
  return false;
};
===>
const areEqual = (prevprops, nextProps) => {
  return prevprops.obj.count === nextProps.obj.count;
};
//이렇게 변경 가능하다

---> 결론 
memoizatnion된 counterB는 버튼을 눌러도 얕은 검사를 하지 않기 때문에 값이 변화되지 않얐다고 판단하고 리랜더하지 않는다 




useCallback()

컴포넌트를 최적화 하는 이유
state, props, parents 의변화가 일어날때 리랜더가 된다 
--> 이때 소모되는 리랜더 방지 
memozation된 콜백 함수를 반환한다 
useMemo는 함수가 아니라 값을 반환하는것이기때문에 함수를 반환할때는 useCallback()을 사용하는것 같다 
useCallback(()=>{

},[])
두번째 인자로 받은 객체가 변하지 않으면 콜백함수를 재사용할수 있도록 도와주는 리액트 hook 
-->빈배열로 전달해서 mount되는 시점을 한번으로 만들고 그 이후로는 처음만든 함수를 재사용한다.

주의 --> 빈배열을 넣어줘서 그동안의 일기리스트가 사라짐 ----> 그래서 다시 data값을 받으면 data가 업데이트 될때마다 mount되는 딜레마가 생김 
---->함수형 업데이트 사용!!!!
setState함수에 함수를 전달하는걸 함수형 업데이트라고 한다
그러면 빈배열을 전달해서 setState에서 전달받은 인자를 참고한다
----
//새로운일기추가함수
const onCreate = useCallback((author, content, emotion) => {
  const created_date = new Date().getTime();
  const newItem = {
    author,
    content,
    emotion,
    created_date,
    id: dataId.current,
  };
  dataId.current += 1;
  setData((data) => [newItem, ...data]); --> 함수형 업데이트를 사용!!!! data값을 최신의 값으로 유지한다
}, []);---> 빈배열 전달 : 한번만 mount한다 
----


최적화하기 
diaryItem.js
-> 일기리스트 아이템 한개를 삭제해도 모든 아이템이 랜더링이 되서 메모리 낭비가 심해진다 
1. React.memo로 컴포넌트를 묶어준다 
2. React 를impor 한다 
3. useEffect를 사용해서 리랜더링되는 부분을 알아본다 
----
const DiaryItem = ({
  onEdit,
  onRemove,  --> 이 두가지 함수는 dataState가 변화하면 재생성되는 함수다 이것을 app.js에서 최적화 시켜준다
  id,
  author,
  content,
  created_date,
  emotion,
}) => {......
-------
4.
onRemove() 코드 수정하기 
----
const onRemove = useCallback((targetId) => {
  const newDiaryList = data.filter((it) => it.id !== targetId);
  setData(newDiaryList);
},[])
---->>>> 함수형 업데이트는 인자를 받아야 한다 
const onRemove = useCallback((targetId) => {
  setData((data) => data.filter((it) => it.id !== targetId));
}, []);
----

