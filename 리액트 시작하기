구글에 codesandbox 검색- try to free 선택 - 바닐라 스크립트 선택

1. 변수와 상수 
자바스크립트 에서 변수 만들기 
let age = 25; 
값에 이름을 붙여준다.

규칙 
1. 변수명에 언더스코어와 달러는 사용가능하다
2. 숫자가 아닌 문자로 시작해야 한다.
3. 예약어는 사용 불가능.
var 도 사용 가능 
let은 변수를 중복해서 선언하는 것을 허용하지 않지만 var는 사용가능해서 혼용의 위험성이 있다. 

상수 - 변하지 않는 값 
선언후에 값을 바꿀 수가 없다 

2. 자료형과 형변환 
자바스크립트의 자료형
값을 성질에 따라 분류한것 
primitive date type 내장, 기본형 타입 한번에 한가지 값만 가질 수 있다.
number, string, undefined, null , boolean

none-premitive type () 한번에 여러가지 값을 가질 수 있다.

1. 
let inf = Infinity;
let minusInf = -Infinity;
let nan = NaN;  수학적 연산의 실패값 
2. 문자열
큰따음표, 작은 따음표, 백팁을 사용한다. -> 문자열에 ${} 로 변수의 값을 사용가능 -> 템플릿 leterl 이라고 함 

3. boolean 값의 true, false저장
4. null 의도적으로 아무값도 담고 있지 않게 함  
5. undefine 값을 할당 하지 않은 상태.

형변환 Casting
문자열을 숫자로 자료형 변환을 시키는 기능. 
let numA = 12;
let numB = "2";

console.log(numA + parseInt(numB)); //  parseInt()문자열을 숫자로 변환 

2-4 연산자 
-대입연산자 변수에 값을 넣는것 
-사칙연산 (+, -, *, /, %)
-연결연산 두개이상의 문자열을 이어붙이는 연산 
-복합연산 
let a = 5; 
a += 10 
-증감연산자 

typeof 변수명 -> 변수의 자료형을  출력 

null 병합연산 
a가 null 이면 식 대입

let a;
a = a ?? 10;
console.log(a);

조건문 switch

let conutry = "ko";

switch (conutry) {
  case "ko":
    console.log("한국");
    break;
  case "cn":
    console.log("중국");
    break;
  case "jp":
    console.log("일본");
    break;
  case "uk":
    console.log("영국");
    break;
  default:
    console.log("미 분류");
}

함수
function getArea() {
  let width1 = 10;
  let height1 = 20;

  let area = width1 * height1;
  console.log(area);
} // 함수선언식

getArea(); // 함수 호출

함수호출시 인자 값을 받는 매개변수 넣기
function getArea(width , height) {

  let area = width * height;
  console.log(area);
}

getArea(10,20);

반환
return 으로 값 반환하기 
function getArea(width, height) {
  let area = width * height;
  return area;
}
let area1 = getArea(100, 200);
console.log(area1);

함수를 값 처럼 취급해서 사용해보기 
함수 표현식: 함수를 변수에 담아 사용
1. 변수는 함수를 담을 수 있다.
let hello = function () {
  return "안녕하세요";
}; 
console.log(hello);
2. 함수를 담은 변수이름을 함수의 이름처럼 사용 
let hello = function () {
  return "안녕하세요";
};
const hellotext = hello();
console.log(hellotext);

함수선언식과 표현식의 차이 
- 함수 선언식은 코드 아래에 위치해도 위에서 호출가능 (호이스팅O)

화살표함수 
무명함수를 간단하고 빠르게 작성을 도와주는 문법 
(호이스팅 x)
let hello = () => {
  return "안녕하세요";
};
console.log(hello());
--------------
let hello = () => "안녕하세요";
console.log(hello());

2-8 콜백함수 
함수의 파라미터로 함수를 넘긴다. 
function checkMood(mood, goodCallback, badCAllback) {
  if (mood === "good") {
    goodCallback();
  } else {
    badCAllback();
  }
}

function cry() {
  console.log("action :: cry");
}
function sing() {
  console.log("action :: sing");
}
function dance() {
  console.log("action :: dance");
}
checkMood("good", sing, cry);

함수를 값에 담는 함수 표현식의 개념을 이용해서 매개변수에 담아 호출하면 결론적으로 매개변수안에 담겨진 함수를 호출하게 된다 

2-9 객체
객체 만드는법 
1. 객체 생성자 
let person = new Object();
2. let person = {}; 객체 리터럴 방식

객체의 키와 값에는 모든 문자열이 가능하다
let person = {
  key : "value",
  key1 : 1, //속성, 객체 프로퍼디, 객체의 데이터
  key2 : true,
  key3 : undefined,
  key4 : [1,2],
  key5 : function (){}
};

console.log(person);
console.log(person.key1);//특정값 꺼내기, 점 표기법
----
let person = {
  name: "mike",
  age: 25
};

console.log(person.name);
console.log(person["name"]); // 대가로 사용, 점표기법과 같은 결과, 반드시 "문자열" 사용 아니면 뱐수로 인식함 
----
console.log(getPropertyValue("name"));

function getPropertyValue(key) {
  return person[key];
}
고정되지 않은 값에 접근할 때 가로 표기법으로 사용한다. 

객체 프로퍼티 생성이후 추가, 삭제하는법 
1.추가
let person = {
  name: "mike",
  age: 25
};

person.location = "한국";
console.log(person);
2. 수정 (상수 객채의 값도 수정가능)
const person = {
  name: "mike",
  age: 25
};

person.location = "한국";
person["gender"] = "male";
person.name = "han";
person["age"] = "40";
console.log(person);

3. 삭제
let person = {
  name: "mike",
  age: 25
};

delete person.age; //메모리에 남아있음
person.name = null; //메모리에서 삭제
console.log(person);

메소드
let person = {
  name: "mike", //member
  age: 25, //member
  say: function () {
    console.log("hello");
  }// methd 객체안에 담신 함수
};
person.say();
----
let person = {
  name: "mike", //member
  age: 25, //member
  say: function () {
    console.log(`안녕 나는 ${this.name}`);
  } // methd 객체안에 담신 함수
};
person.say();

프로퍼티가 존재하는지 확인 하는 법 
console.log(`${"name" in person}`); //in 연산자 사용

배열
순서있는 요소들의 집합
만드는 법 
1. let arr = new Arrray();
2. let arr = []; //배열리터럴
----
let arr = [];
console.log(arr); // 배열 출력 
----
모든 자료형 가능
let arr = [1, "2", true, undefined, {}, [], function () {}];
console.log(arr);
-각각의 요소에 접근하기 
console.log(arr[0]); //인덱스사용
-추가하기
arr.push(6); //push함수 사용시 가장 마지막에 추가됨
arr.push({ key: "value" }); // 객체도 추가 가능 
-배열길이 알기
console.log(arr.length);

반복문
-100번 이름 출력하기
for (let i = 1; i <= 100; i++) {
  console.log("hey");
}
----
for (초기식변수, 조건식, 연산 )
-배열요소 반복문으로 순회하기 (ft.인덱스)
const arr = ["a", "b", "c"];

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
-객체 순회하는 방법
let person = {
  name: "mile",
  age: 25,
  tall: 180
};

const personKeys = Object.keys(person); //객체의 키를배열로반환

for (let i = 0; i < personKeys.length; i++) {
  console.log(personKeys[i]);
}

객체의 키와 밸류 확인하기 
----
let person = {
  name: "mile",
  age: 25,
  tall: 180
};

const personKeys = Object.keys(person); //객체의 키를배열로반환

for (let i = 0; i < personKeys.length; i++) {
  const curKey = personKeys[i];
  const curValue = person[curKey];
  console.log(`${curKey}:${curValue}`);
}
----

배열내장함수
-forEach() 배열요소순환
const arr = [1, 2, 3, 4];

arr.forEach(function (elm) { //콜백함수를 각각의 배열요소에 실행함 
  console.log(elm);
});

-map() 배열요소를 순환하면서 값을 따로 새로운 배열로 저장함
const arr = [1, 2, 3, 4];
const newArr = arr.map((elm) => {
  return elm * 2; //리턴된값을 따로 배열로 반환함
});

console.log(newArr);

-배열안에 3이 있는지 확인하는법
const arr = [1, 2, 3, 4];

let number = 3;

arr.forEach((elm) => {
  if (elm === number) {
    console.log(true);
  }
});

-includes() 배열에서 전달받은 인자가 존재하는지를 확인함
console.log(arr.includes(number));

-배열에서 그값이 몇번째에 있는지 알려줌 없으면 -1
console.log(arr.indexOf(number));

-findIndex()
배열을 처음부터 끝까지 순서대로 순회하면서 조건에 만족하는 요소의 인덱스를 반환하는 함수
const arr = [
  { color: "red" },
  { color: "yellow" },
  { color: "blue" },
  { color: "green" }
]; 

console.log(arr.findIndex((elm) => elm.color === "blue"));
==> 
console.log(arr.findIndex((elm) => {
  return elm.color === "blue";
}));

-조건에 일치하는 요소를 가져옴
const arr = [
  { color: "red" },
  { color: "yellow" },
  { color: "blue" },
  { color: "green" }
];

const element = arr.find((elm) => elm.color === "red");

console.log(element);

- filter() 배열필터링 하기 
콜백함수가 반화하는 모든 요소를 배열로 반환

-slice()
잘라서 새로운 배열로 반환해줌
console.log(arr.slice(0, 2));// end가 2면 0,1 이 반환됨

-concat()
const arr = [
  { num: 1, color: "red" },
  { num: 2, color: "yellow" }
];

const arr2 = [
  { num: 3, color: "blue" },
  { num: 4, color: "green" }
];

console.log(arr.concat(arr2));

-sort()
원본배열을 정렬해줌 , 문자열기준
let chrs = ["나", "다", "가"];

chrs.sort();
console.log(chrs);

-join()
const arr = ["안녕", "하세요", "반갑", "습니다."];

console.log(arr.join(""));// "" 공백을 넣어주면 쉼표가 사라짐, ""안에 다른 것도 추가 가능 

3.truthy & falsy
자바스크립트가 자신만의 기준으로 값을 true나 false로 정의함
조건식에서 true로 인식하는것들 -> [] , 숫자, "문자열" , infinty  -> truthy
null, undefined, false, -, 0, NaN, "" -> flasy
코딩에서 이 개념을 활용할 수 있다

const getName = (person) => {
  if (person === undefined || person === null) { //조건문을 참으로 만들어 에러가 발생하지 않게 함
    return "객체가 아닙니다";
  }
  return person.name;
};

let person = null;
const name = getName(person);
console.log(name);

=> if (!person) { //false값이 들어가도 not이되서 true가 됨
    return "객체가 아닙니다";
  } //더 간단하게 조건문 수정가능

삼항 연산자
-조건문 한줄 끝내기
let a = 3;
if (a >= 0) {
  console.log("양수");
} else {
  console.log("음수");
}
=>>
let a = 3;
a >= 0 ? console.log("양수") : console.log("음수");// 조건?참:거짓
값을 반환하게 수정
=>>
const arryStatus = a.length === 0 ? "빈배열입니다" : "비어있지안습니다.";
console.log(arryStatus);

-주어진 값이 null이거나 undefined이아닌지 판다하는 함수 만들기let a;

const result = a ? true : false;
console.log(result);
=> truthy와 falsy 개념 이용 가능 

-삼항 연산자 중첩 활용하기 
//학점계산 프로그램
//90이상 A+
//50이상 B+
//둘다아니면F

let score = 100;

score >= 90
  ? console.log("A+")
  : score >= 50
  ? console.log("B+")
  : console.log("F"); //중첩으로 사용하면 가독성이 떨어지기때문에 if문 사용
=>>
if (score >= 90) {
  console.log("A+");
} else if (score >= 50) {
  console.log("B+");
} else {
  console.log("F");
}

단락회로평가
왼쪽-> 오른쪽 으로 향하는 논리연산자의 연산 순서를 이용하는 문법
console.log(false && true);
&&은 둘다 true인 경우에만 참이기 때문에 한쪽이 false면 그냥 false이다 -> 단락평가가 이루어짐

-단락회로 평가를 truth나 falsy에 사용하기
const getName = (person) => {
  if (!person) {//null인지 undefined인지 검사
    return "객체가 아닙니다.";
  } else {
   return person.name;
  }
};
let person;
const name = getName(person);

console.log(name);
->>
const getName = (person) => {
  return person && person.naem;//falsy 면 그값을 그대로 리턴함
};

---- 여기에 객체가 아니면 아니라는 문구가 나오게 추가 
const getName = (person) => {
  const name = person && person.name; //person이 true이기 때문에 person.name값을 반환함
  return name || "객체가아닙니다."; //name의 값이 truthy "mike"이기 때문에 뒤는 보지않고 이름을 출력함
};
let person = { name: "mike" };
const name = getName(person);

console.log(name);

정리 
변수에 참이나 거짓의 값을 담고 || 를 이용해서 리턴값이 truthy 나 falsy에 따라 달라지게 나옴 

조건문 업그레이드
-주어진 문자열이 한식에 해당하는지 검사
function isKoreanFood(food) {
  if (food === "불고기" || food === "비빔밥" || food === "떡볶이") {
    return true;
  }
  return false;
}
const food1 = isKoreanFood("불고기");
console.log(food1);
--> 많은 음식종류를 다 입력하기 불가능
if (["불고기" || "떡복이" || "비빔밥"].includes(food)) {
    return true;
  }
  return false;
}
--> inclodse() 사용가능

-객체의 가로표기법 사용하기
const meal = {
  한식: "비빔밥",
  일식: "초밥",
  중식: "마라탕",
  인도: "카레"
};

const getMeal = (mealType) => {
  return meal[mealType] || "굶기";
};

console.log(getMeal("한식"));//키를적으면 메뉴가나옴

3-5 비구조화 할당 (배열, 객체)
배열의 비구조화 할당
-대가로를 이용해서 배열의 값을 순서대로 할당받아 사용할수 있다.

let arr = ["one", "two", "three"];

let [one, two, three] = arr; //배열안에 변수 3개 선언, arr이라는 배열을 만듬

console.log(one, two, three);
==> arr을 사용하지 않아도됨
let [one, two, three] = ["one", "two", "three"]; 
배열의 요소를 순서대로 변수에 할당하는 방법

변수에 기본값 넣는방법
let [one, two, three, four] = ["one", "two", "three"];

console.log(one, two, three, four); -->four에 값이 없어서 undefied이 출력됨
--> four에 기본값 할당해줌
let [one, two, three, four = "four"] = ["one", "two", "three"];

console.log(one, two, three, four);

-swap
let a = 10;
let b = 20;
let tmp = 0;
tmp = a;
a = b;
b = tmp;
console.log(a, b);
--> 이것도 대가로로 이요해서 줄여줌
let a = 10;
let b = 20;
[a, b] = [b, a];
console.log(a, b);

-오브젝트에 값을 할당하기 위해 서 정표기법이나 가로표기법사용함
let object = { one: "one", two: "two", three: "three" };

let one = object.one;//or object["one"]
let two = object.two;
let three = object.three;

console.log(one, two, three);
--> 줄이기 키값을 기준으로 할당을 함 
let object = { one: "one", two: "two", three: "three", name: "mike" };

let { one, two, three, name } = object; //오브젝트에 키값을 기준으로 값이 들어감
console.log(one, two, three, name);


