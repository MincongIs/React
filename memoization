useMemo 
memoization

1. appjs 리턴문 위에 3가지 함수를 만든다
const getDiaryAnalysis = ()=> {
  console.log("일기 분석 시작");
}
2. 기분좋은 일기 구하기 감정점수가 3이상인것 
  const goodCount = data.filter((it)=>it.emotion >=3).length;
3. 기분나쁜일기구하기
  const badCount = data.length-goodCount;
4. 좋은 일기 비율구하기
const goodRatio = (goodCount/ data.length)*100;
5. 3가지를 객체로 리턴하기
return {goodCount, badCount,goodRatio};

----
const getDiaryAnalysis = ()=> {
  console.log("일기 분석 시작");
  const goodCount = data.filter((it)=>it.emotion >=3).length;
  const badCount = data.length-goodCount;
  const goodRatio = (goodCount/ data.length)*100;
  return {goodCount, badCount,goodRatio};
}
----
6. 지역함수로 만든 getDiaryAnalysis()를 리턴전에 호출한다 
const {goodCount, badCount,goodRatio} = getDiaryAnalysis();
7. 이렇게 얻은 3개의 데이터를 호출한다 
<div>전체 일기 : {data.length}</div>
<div>기분 좋은 일기 개수 : {goodCount}</div>
<div>기분 나쁜 일기 개수 : {badCount}</div>
<div>기분 좋은 일기 비율 : {goodRatio}</div>

8. 리턴을 가지고 있는 함수를 memoization해서 연산을 최적화 하기 위해서는 useMemo()를 사용 
사용하고자하는 함수를 useMemo()함수로 감싸준다
 const getDiaryAnalysis = useMemo(() => {
  console.log("일기 분석 시작");
  const goodCount = data.filter((it) => it.emotion >= 3).length;
  const badCount = data.length - goodCount;
  const goodRatio = (goodCount / data.length) * 100;
  return { goodCount, badCount, goodRatio };
},[data.length]);
--> 즉 useMemo함수는 첫번째 인자로 콜백함수를 갖는다 
두번째로 전데이터의 갯수가 달라지면 콜백함수가 호출이 된다 
9. getDiaryAnalysis는 이제 함수가 아니고 콜백함수가 내보는값을 가지게 된다 



정리....
useMemo()는 첫번째 인자로 콜백함수를 가져서 콤백함수가 러턴하는 값의 연산을 최적화 할 수 있도록 해준다
두번째 인자로는 배열이 들어가는데 이 배열이 변화 할때만 콜백함수가 실행이 된다 
그렇다는것은 이 것을 아무리 호출을 해도 배열에 변화가 생기지않는 한 똑같이 이전에 계산했던 값만 리턴해서 내보낸다는 뜻이다.
즉 똑같은 문제를 풀어하는데 새로계산할 필요가 없으면 기존의 알고있던 답을 내놓는것과 같다
*** useMemo로 함수를 감싸서 최적화를 하면 더이상 함수가 아니라 값만 리턴하는 상태가 된다 
